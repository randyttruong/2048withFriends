{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useCallback, useEffect, useReducer, useRef } from \"react\";\nimport { animationDuration, tileCount as tileCountPerRowOrColumn } from \"../../../Board\";\nimport { useIds } from \"../useIds\";\nimport { GameReducer, initialState } from \"./reducer\";\nexport const useGame = () => {\n  _s();\n  const isInitialRender = useRef(true);\n  const [nextId] = useIds();\n  // state\n  const [state, dispatch] = useReducer(GameReducer, initialState);\n  const {\n    tiles,\n    byIds,\n    hasChanged,\n    inMotion\n  } = state;\n  const createTile = useCallback(({\n    position,\n    value\n  }) => {\n    const tile = {\n      id: nextId(),\n      position,\n      value\n    };\n    dispatch({\n      type: \"CREATE_TILE\",\n      tile\n    });\n  }, [nextId]);\n  const mergeTile = (source, destination) => {\n    dispatch({\n      type: \"MERGE_TILE\",\n      source,\n      destination\n    });\n  };\n\n  // A must-have to keep the sliding animation if the action merges tiles together.\n  const throttledMergeTile = (source, destination) => {\n    setTimeout(() => mergeTile(source, destination), animationDuration);\n  };\n  const updateTile = tile => {\n    dispatch({\n      type: \"UPDATE_TILE\",\n      tile\n    });\n  };\n  const didTileMove = (source, destination) => {\n    const hasXChanged = source.position[0] !== destination.position[0];\n    const hasYChanged = source.position[1] !== destination.position[1];\n    return hasXChanged || hasYChanged;\n  };\n  const retrieveTileMap = useCallback(() => {\n    const tileMap = new Array(tileCountPerRowOrColumn * tileCountPerRowOrColumn).fill(0);\n    byIds.forEach(id => {\n      const {\n        position\n      } = tiles[id];\n      const index = positionToIndex(position);\n      tileMap[index] = id;\n    });\n    return tileMap;\n  }, [byIds, tiles]);\n  const findEmptyTiles = useCallback(() => {\n    const tileMap = retrieveTileMap();\n    const emptyTiles = tileMap.reduce((result, tileId, index) => {\n      if (tileId === 0) {\n        return [...result, indexToPosition(index)];\n      }\n      return result;\n    }, []);\n    return emptyTiles;\n  }, [retrieveTileMap]);\n  const generateRandomTile = useCallback(() => {\n    const emptyTiles = findEmptyTiles();\n    if (emptyTiles.length > 0) {\n      const index = Math.floor(Math.random() * emptyTiles.length);\n      const position = emptyTiles[index];\n      createTile({\n        position,\n        value: 2\n      });\n    }\n  }, [findEmptyTiles, createTile]);\n  const positionToIndex = position => {\n    return position[1] * tileCountPerRowOrColumn + position[0];\n  };\n  const indexToPosition = index => {\n    const x = index % tileCountPerRowOrColumn;\n    const y = Math.floor(index / tileCountPerRowOrColumn);\n    return [x, y];\n  };\n  const move = (retrieveTileIdsPerRowOrColumn, calculateFirstFreeIndex) => {\n    // new tiles cannot be created during motion.\n    dispatch({\n      type: \"START_MOVE\"\n    });\n    const maxIndex = tileCountPerRowOrColumn - 1;\n\n    // iterates through every row or column (depends on move kind - vertical or horizontal).\n    for (let rowOrColumnIndex = 0; rowOrColumnIndex < tileCountPerRowOrColumn; rowOrColumnIndex += 1) {\n      // retrieves tiles in the row or column.\n      const availableTileIds = retrieveTileIdsPerRowOrColumn(rowOrColumnIndex);\n\n      // previousTile is used to determine if tile can be merged with the current tile.\n      let previousTile;\n      // mergeCount helps to fill gaps created by tile merges - two tiles become one.\n      let mergedTilesCount = 0;\n\n      // interate through available tiles.\n      availableTileIds.forEach((tileId, nonEmptyTileIndex) => {\n        const currentTile = tiles[tileId];\n\n        // if previous tile has the same value as the current one they should be merged together.\n        if (previousTile !== undefined && previousTile.value === currentTile.value) {\n          const tile = {\n            ...currentTile,\n            position: previousTile.position,\n            mergeWith: previousTile.id\n          };\n\n          // delays the merge by 250ms, so the sliding animation can be completed.\n          throttledMergeTile(tile, previousTile);\n          // previous tile must be cleared as a single tile can be merged only once per move.\n          previousTile = undefined;\n          // increment the merged counter to correct position for the consecutive tiles to get rid of gaps\n          mergedTilesCount += 1;\n          return updateTile(tile);\n        }\n\n        // else - previous and current tiles are different - move the tile to the first free space.\n        const tile = {\n          ...currentTile,\n          position: indexToPosition(calculateFirstFreeIndex(rowOrColumnIndex, nonEmptyTileIndex, mergedTilesCount, maxIndex))\n        };\n\n        // previous tile become the current tile to check if the next tile can be merged with this one.\n        previousTile = tile;\n\n        // only if tile has changed its position it will be updated\n        if (didTileMove(currentTile, tile)) {\n          return updateTile(tile);\n        }\n      });\n    }\n\n    // wait until the end of all animations.\n    setTimeout(() => dispatch({\n      type: \"END_MOVE\"\n    }), animationDuration);\n  };\n  const moveLeftFactory = () => {\n    const retrieveTileIdsByRow = rowIndex => {\n      const tileMap = retrieveTileMap();\n      const tileIdsInRow = [tileMap[rowIndex * tileCountPerRowOrColumn + 0], tileMap[rowIndex * tileCountPerRowOrColumn + 1], tileMap[rowIndex * tileCountPerRowOrColumn + 2], tileMap[rowIndex * tileCountPerRowOrColumn + 3]];\n      const nonEmptyTiles = tileIdsInRow.filter(id => id !== 0);\n      return nonEmptyTiles;\n    };\n    const calculateFirstFreeIndex = (tileIndex, tileInRowIndex, howManyMerges, _) => {\n      return tileIndex * tileCountPerRowOrColumn + tileInRowIndex - howManyMerges;\n    };\n    return move.bind(this, retrieveTileIdsByRow, calculateFirstFreeIndex);\n  };\n  const moveRightFactory = () => {\n    const retrieveTileIdsByRow = rowIndex => {\n      const tileMap = retrieveTileMap();\n      const tileIdsInRow = [tileMap[rowIndex * tileCountPerRowOrColumn + 0], tileMap[rowIndex * tileCountPerRowOrColumn + 1], tileMap[rowIndex * tileCountPerRowOrColumn + 2], tileMap[rowIndex * tileCountPerRowOrColumn + 3]];\n      const nonEmptyTiles = tileIdsInRow.filter(id => id !== 0);\n      return nonEmptyTiles.reverse();\n    };\n    const calculateFirstFreeIndex = (tileIndex, tileInRowIndex, howManyMerges, maxIndexInRow) => {\n      return tileIndex * tileCountPerRowOrColumn + maxIndexInRow + howManyMerges - tileInRowIndex;\n    };\n    return move.bind(this, retrieveTileIdsByRow, calculateFirstFreeIndex);\n  };\n  const moveUpFactory = () => {\n    const retrieveTileIdsByColumn = columnIndex => {\n      const tileMap = retrieveTileMap();\n      const tileIdsInColumn = [tileMap[columnIndex + tileCountPerRowOrColumn * 0], tileMap[columnIndex + tileCountPerRowOrColumn * 1], tileMap[columnIndex + tileCountPerRowOrColumn * 2], tileMap[columnIndex + tileCountPerRowOrColumn * 3]];\n      const nonEmptyTiles = tileIdsInColumn.filter(id => id !== 0);\n      return nonEmptyTiles;\n    };\n    const calculateFirstFreeIndex = (tileIndex, tileInColumnIndex, howManyMerges, _) => {\n      return tileIndex + tileCountPerRowOrColumn * (tileInColumnIndex - howManyMerges);\n    };\n    return move.bind(this, retrieveTileIdsByColumn, calculateFirstFreeIndex);\n  };\n  const moveDownFactory = () => {\n    const retrieveTileIdsByColumn = columnIndex => {\n      const tileMap = retrieveTileMap();\n      const tileIdsInColumn = [tileMap[columnIndex + tileCountPerRowOrColumn * 0], tileMap[columnIndex + tileCountPerRowOrColumn * 1], tileMap[columnIndex + tileCountPerRowOrColumn * 2], tileMap[columnIndex + tileCountPerRowOrColumn * 3]];\n      const nonEmptyTiles = tileIdsInColumn.filter(id => id !== 0);\n      return nonEmptyTiles.reverse();\n    };\n    const calculateFirstFreeIndex = (tileIndex, tileInColumnIndex, howManyMerges, maxIndexInColumn) => {\n      return tileIndex + tileCountPerRowOrColumn * (maxIndexInColumn - tileInColumnIndex + howManyMerges);\n    };\n    return move.bind(this, retrieveTileIdsByColumn, calculateFirstFreeIndex);\n  };\n  useEffect(() => {\n    if (isInitialRender.current) {\n      createTile({\n        position: [0, 1],\n        value: 2\n      });\n      createTile({\n        position: [0, 2],\n        value: 2\n      });\n      isInitialRender.current = false;\n      return;\n    }\n    if (!inMotion && hasChanged) {\n      generateRandomTile();\n    }\n  }, [hasChanged, inMotion, createTile, generateRandomTile]);\n  const tileList = byIds.map(tileId => tiles[tileId]);\n  const moveLeft = moveLeftFactory();\n  const moveRight = moveRightFactory();\n  const moveUp = moveUpFactory();\n  const moveDown = moveDownFactory();\n  return [tileList, moveLeft, moveRight, moveUp, moveDown];\n};\n_s(useGame, \"naw0Phe6GKEGdp4fIQMPrzCLcuQ=\", false, function () {\n  return [useIds];\n});","map":{"version":3,"names":["useCallback","useEffect","useReducer","useRef","animationDuration","tileCount","tileCountPerRowOrColumn","useIds","GameReducer","initialState","useGame","_s","isInitialRender","nextId","state","dispatch","tiles","byIds","hasChanged","inMotion","createTile","position","value","tile","id","type","mergeTile","source","destination","throttledMergeTile","setTimeout","updateTile","didTileMove","hasXChanged","hasYChanged","retrieveTileMap","tileMap","Array","fill","forEach","index","positionToIndex","findEmptyTiles","emptyTiles","reduce","result","tileId","indexToPosition","generateRandomTile","length","Math","floor","random","x","y","move","retrieveTileIdsPerRowOrColumn","calculateFirstFreeIndex","maxIndex","rowOrColumnIndex","availableTileIds","previousTile","mergedTilesCount","nonEmptyTileIndex","currentTile","undefined","mergeWith","moveLeftFactory","retrieveTileIdsByRow","rowIndex","tileIdsInRow","nonEmptyTiles","filter","tileIndex","tileInRowIndex","howManyMerges","_","bind","moveRightFactory","reverse","maxIndexInRow","moveUpFactory","retrieveTileIdsByColumn","columnIndex","tileIdsInColumn","tileInColumnIndex","moveDownFactory","maxIndexInColumn","current","tileList","map","moveLeft","moveRight","moveUp","moveDown"],"sources":["/home/randyt/projects/2048final/src/components/Game/hooks/useGame/useGame.ts"],"sourcesContent":["import { useCallback, useEffect, useReducer, useRef } from \"react\";\nimport {\n  animationDuration,\n  tileCount as tileCountPerRowOrColumn,\n} from \"../../../Board\";\nimport { TileMeta } from \"../../../Tile\";\nimport { useIds } from \"../useIds\";\nimport { GameReducer, initialState } from \"./reducer\";\n\nexport const useGame = () => {\n  const isInitialRender = useRef(true);\n  const [nextId] = useIds();\n  // state\n  const [state, dispatch] = useReducer(GameReducer, initialState);\n  const { tiles, byIds, hasChanged, inMotion } = state;\n\n  const createTile = useCallback(\n    ({ position, value }: Partial<TileMeta>) => {\n      const tile = {\n        id: nextId(),\n        position,\n        value,\n      } as TileMeta;\n      dispatch({ type: \"CREATE_TILE\", tile });\n    },\n    [nextId]\n  );\n\n  const mergeTile = (source: TileMeta, destination: TileMeta) => {\n    dispatch({ type: \"MERGE_TILE\", source, destination });\n  };\n\n  // A must-have to keep the sliding animation if the action merges tiles together.\n  const throttledMergeTile = (source: TileMeta, destination: TileMeta) => {\n    setTimeout(() => mergeTile(source, destination), animationDuration);\n  };\n\n  const updateTile = (tile: TileMeta) => {\n    dispatch({ type: \"UPDATE_TILE\", tile });\n  };\n\n  const didTileMove = (source: TileMeta, destination: TileMeta) => {\n    const hasXChanged = source.position[0] !== destination.position[0];\n    const hasYChanged = source.position[1] !== destination.position[1];\n\n    return hasXChanged || hasYChanged;\n  };\n\n  const retrieveTileMap = useCallback(() => {\n    const tileMap = new Array(\n      tileCountPerRowOrColumn * tileCountPerRowOrColumn\n    ).fill(0) as number[];\n\n    byIds.forEach((id) => {\n      const { position } = tiles[id];\n      const index = positionToIndex(position);\n      tileMap[index] = id;\n    });\n\n    return tileMap;\n  }, [byIds, tiles]);\n\n  const findEmptyTiles = useCallback(() => {\n    const tileMap = retrieveTileMap();\n\n    const emptyTiles = tileMap.reduce((result, tileId, index) => {\n      if (tileId === 0) {\n        return [...result, indexToPosition(index) as [number, number]];\n      }\n\n      return result;\n    }, [] as [number, number][]);\n\n    return emptyTiles;\n  }, [retrieveTileMap]);\n\n  const generateRandomTile = useCallback(() => {\n    const emptyTiles = findEmptyTiles();\n\n    if (emptyTiles.length > 0) {\n      const index = Math.floor(Math.random() * emptyTiles.length);\n      const position = emptyTiles[index];\n\n      createTile({ position, value: 2 });\n    }\n  }, [findEmptyTiles, createTile]);\n\n  const positionToIndex = (position: [number, number]) => {\n    return position[1] * tileCountPerRowOrColumn + position[0];\n  };\n\n  const indexToPosition = (index: number) => {\n    const x = index % tileCountPerRowOrColumn;\n    const y = Math.floor(index / tileCountPerRowOrColumn);\n    return [x, y];\n  };\n\n  type RetrieveTileIdsPerRowOrColumn = (rowOrColumnIndex: number) => number[];\n\n  type CalculateTileIndex = (\n    tileIndex: number,\n    tileInRowIndex: number,\n    howManyMerges: number,\n    maxIndexInRow: number\n  ) => number;\n\n  const move = (\n    retrieveTileIdsPerRowOrColumn: RetrieveTileIdsPerRowOrColumn,\n    calculateFirstFreeIndex: CalculateTileIndex\n  ) => {\n    // new tiles cannot be created during motion.\n    dispatch({ type: \"START_MOVE\" });\n\n    const maxIndex = tileCountPerRowOrColumn - 1;\n\n    // iterates through every row or column (depends on move kind - vertical or horizontal).\n    for (\n      let rowOrColumnIndex = 0;\n      rowOrColumnIndex < tileCountPerRowOrColumn;\n      rowOrColumnIndex += 1\n    ) {\n      // retrieves tiles in the row or column.\n      const availableTileIds = retrieveTileIdsPerRowOrColumn(rowOrColumnIndex);\n\n      // previousTile is used to determine if tile can be merged with the current tile.\n      let previousTile: TileMeta | undefined;\n      // mergeCount helps to fill gaps created by tile merges - two tiles become one.\n      let mergedTilesCount = 0;\n\n      // interate through available tiles.\n      availableTileIds.forEach((tileId, nonEmptyTileIndex) => {\n        const currentTile = tiles[tileId];\n\n        // if previous tile has the same value as the current one they should be merged together.\n        if (\n          previousTile !== undefined &&\n          previousTile.value === currentTile.value\n        ) {\n          const tile = {\n            ...currentTile,\n            position: previousTile.position,\n            mergeWith: previousTile.id,\n          } as TileMeta;\n\n          // delays the merge by 250ms, so the sliding animation can be completed.\n          throttledMergeTile(tile, previousTile);\n          // previous tile must be cleared as a single tile can be merged only once per move.\n          previousTile = undefined;\n          // increment the merged counter to correct position for the consecutive tiles to get rid of gaps\n          mergedTilesCount += 1;\n\n          return updateTile(tile);\n        }\n\n        // else - previous and current tiles are different - move the tile to the first free space.\n        const tile = {\n          ...currentTile,\n          position: indexToPosition(\n            calculateFirstFreeIndex(\n              rowOrColumnIndex,\n              nonEmptyTileIndex,\n              mergedTilesCount,\n              maxIndex\n            )\n          ),\n        } as TileMeta;\n\n        // previous tile become the current tile to check if the next tile can be merged with this one.\n        previousTile = tile;\n\n        // only if tile has changed its position it will be updated\n        if (didTileMove(currentTile, tile)) {\n          return updateTile(tile);\n        }\n      });\n    }\n\n    // wait until the end of all animations.\n    setTimeout(() => dispatch({ type: \"END_MOVE\" }), animationDuration);\n  };\n\n  const moveLeftFactory = () => {\n    const retrieveTileIdsByRow = (rowIndex: number) => {\n      const tileMap = retrieveTileMap();\n\n      const tileIdsInRow = [\n        tileMap[rowIndex * tileCountPerRowOrColumn + 0],\n        tileMap[rowIndex * tileCountPerRowOrColumn + 1],\n        tileMap[rowIndex * tileCountPerRowOrColumn + 2],\n        tileMap[rowIndex * tileCountPerRowOrColumn + 3],\n      ];\n\n      const nonEmptyTiles = tileIdsInRow.filter((id) => id !== 0);\n      return nonEmptyTiles;\n    };\n\n    const calculateFirstFreeIndex = (\n      tileIndex: number,\n      tileInRowIndex: number,\n      howManyMerges: number,\n      _: number\n    ) => {\n      return (\n        tileIndex * tileCountPerRowOrColumn + tileInRowIndex - howManyMerges\n      );\n    };\n\n    return move.bind(this, retrieveTileIdsByRow, calculateFirstFreeIndex);\n  };\n\n  const moveRightFactory = () => {\n    const retrieveTileIdsByRow = (rowIndex: number) => {\n      const tileMap = retrieveTileMap();\n\n      const tileIdsInRow = [\n        tileMap[rowIndex * tileCountPerRowOrColumn + 0],\n        tileMap[rowIndex * tileCountPerRowOrColumn + 1],\n        tileMap[rowIndex * tileCountPerRowOrColumn + 2],\n        tileMap[rowIndex * tileCountPerRowOrColumn + 3],\n      ];\n\n      const nonEmptyTiles = tileIdsInRow.filter((id) => id !== 0);\n      return nonEmptyTiles.reverse();\n    };\n\n    const calculateFirstFreeIndex = (\n      tileIndex: number,\n      tileInRowIndex: number,\n      howManyMerges: number,\n      maxIndexInRow: number\n    ) => {\n      return (\n        tileIndex * tileCountPerRowOrColumn +\n        maxIndexInRow +\n        howManyMerges -\n        tileInRowIndex\n      );\n    };\n\n    return move.bind(this, retrieveTileIdsByRow, calculateFirstFreeIndex);\n  };\n\n  const moveUpFactory = () => {\n    const retrieveTileIdsByColumn = (columnIndex: number) => {\n      const tileMap = retrieveTileMap();\n\n      const tileIdsInColumn = [\n        tileMap[columnIndex + tileCountPerRowOrColumn * 0],\n        tileMap[columnIndex + tileCountPerRowOrColumn * 1],\n        tileMap[columnIndex + tileCountPerRowOrColumn * 2],\n        tileMap[columnIndex + tileCountPerRowOrColumn * 3],\n      ];\n\n      const nonEmptyTiles = tileIdsInColumn.filter((id) => id !== 0);\n      return nonEmptyTiles;\n    };\n\n    const calculateFirstFreeIndex = (\n      tileIndex: number,\n      tileInColumnIndex: number,\n      howManyMerges: number,\n      _: number\n    ) => {\n      return (\n        tileIndex +\n        tileCountPerRowOrColumn * (tileInColumnIndex - howManyMerges)\n      );\n    };\n\n    return move.bind(this, retrieveTileIdsByColumn, calculateFirstFreeIndex);\n  };\n\n  const moveDownFactory = () => {\n    const retrieveTileIdsByColumn = (columnIndex: number) => {\n      const tileMap = retrieveTileMap();\n\n      const tileIdsInColumn = [\n        tileMap[columnIndex + tileCountPerRowOrColumn * 0],\n        tileMap[columnIndex + tileCountPerRowOrColumn * 1],\n        tileMap[columnIndex + tileCountPerRowOrColumn * 2],\n        tileMap[columnIndex + tileCountPerRowOrColumn * 3],\n      ];\n\n      const nonEmptyTiles = tileIdsInColumn.filter((id) => id !== 0);\n      return nonEmptyTiles.reverse();\n    };\n\n    const calculateFirstFreeIndex = (\n      tileIndex: number,\n      tileInColumnIndex: number,\n      howManyMerges: number,\n      maxIndexInColumn: number\n    ) => {\n      return (\n        tileIndex +\n        tileCountPerRowOrColumn *\n          (maxIndexInColumn - tileInColumnIndex + howManyMerges)\n      );\n    };\n\n    return move.bind(this, retrieveTileIdsByColumn, calculateFirstFreeIndex);\n  };\n\n  useEffect(() => {\n    if (isInitialRender.current) {\n      createTile({ position: [0, 1], value: 2 });\n      createTile({ position: [0, 2], value: 2 });\n      isInitialRender.current = false;\n      return;\n    }\n\n    if (!inMotion && hasChanged) {\n      generateRandomTile();\n    }\n  }, [hasChanged, inMotion, createTile, generateRandomTile]);\n\n  const tileList = byIds.map((tileId) => tiles[tileId]);\n\n  const moveLeft = moveLeftFactory();\n  const moveRight = moveRightFactory();\n  const moveUp = moveUpFactory();\n  const moveDown = moveDownFactory();\n\n  return [tileList, moveLeft, moveRight, moveUp, moveDown] as [\n    TileMeta[],\n    () => void,\n    () => void,\n    () => void,\n    () => void\n  ];\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}